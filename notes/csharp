https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable?view=netcore-3.1
	Enumerable (class)
		> Provides a set of static (Shared in Visual Basic) methods for querying objects that implement IEnumerable<T>.
		> Enumerable.Range(1,5) -> System.Collections.Generic.IEnumerable<int>
		> Enumerable.Repeat<type>(instance,nb) -> System.Collections.Generic.IEnumerable<type>
		> Enumerable.Min/Max/Aggregate<type>(instance,nb) -> System.Collections.Generic.IEnumerable<type>
			string[] fruits = { "apple", "mango", "orange", "passionfruit", "grape" };
			string longestName = fruits.Aggregate(// Determine whether any string in the array is longer than "banana".
				"banana",
				(longest, next) => next.Length > longest.Length ? next : longest,
				fruit => fruit.ToUpper()// Return the final result as an upper case string.
			);

https://stackoverflow.com/questions/169973/when-should-i-use-a-list-vs-a-linkedlist
	LinkedList
		> Adapted when having to insert elements in the middle of the elements
		> Adapted when iterating forward/backwards only

https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/
	Arrays
		> are reference type
		> int[] array1 = new int[5];
		> int[] array2 = new int[] { 1, 3, 5, 7, 9 };
		> int[] array3 = { 1, 2, 3, 4, 5, 6 };
		> int[,] multiDimensionalArray1 = new int[2, 3];
		> int[,] multiDimensionalArray2 = { { 1, 2, 3 }, { 4, 5, 6 } };
		> int[][] jaggedArray = new int[6][]; jaggedArray[0] = new int[4] { 1, 2, 3, 4 };
		> The difference between multiDimensionalArray and jaggedArray is the flexibility in nested array sizes, and performance (jaggedArray > multiDimensionalArray always)
			https://stackoverflow.com/questions/597720/what-are-the-differences-between-a-multidimensional-array-and-an-array-of-arrays
				Multidimensional arrays (int[2,3] with 2 rows and 3 cols) should be faster for indexation than jagged arrays (int[2][3]), but in practice they are not (sad implementation in CLR + sad JIT for Windows)

http://net-informations.com/faq/oops/struct.htm
	Struct
		> pass-by-copy, hence Value type (created on the stack)
		> does not support inheritance
		> members are public by default (while in classes, they are private by default)
		> not managed by garbage collector (because does not work on heap[tas] but on stack[pile] instead)
		> sizeof(emptyStruct) == 0byte while sizeof(emptyClass) == 1byte

https://docs.microsoft.com/en-us/dotnet/api/system.threading.thread?view=netcore-3.1
	Threads
		> Thread t = new Thread( new ThreadStart(NameOfMethod));
		> t.Name = "Thread1";
		> Console.WriteLine(Thread.CurrentThread.Name);
		> Console.WriteLine(Thread.CurrentThread.ThreadState == ThreadState.Unstarted)
		> t.Start();
		> t.Join()
			https://docs.microsoft.com/en-us/dotnet/api/system.threading.thread.join?view=netcore-3.1
				Join is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose Join method is called has completed.
				Use this method to ensure that a thread has been terminated.
				The caller will block indefinitely if the thread does not terminate.

https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.configureawait?view=netcore-3.1
Task.ConfigureAwait(false): when done, return do NOT try to return to the calling (UI?) thread : https://www.youtube.com/watch?v=3GhKdDCvtKE&t=254s
https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=netcore-3.1
https://docs.microsoft.com/en-us/dotnet/api/system.threading.thread.sleep?view=netcore-3.1
https://www.c-sharpcorner.com/article/task-and-thread-in-c-sharp/
https://en.wikipedia.org/wiki/Semaphore_(programming)
https://docs.microsoft.com/en-us/dotnet/api/system.threading.semaphore?view=netcore-3.1
https://docs.microsoft.com/en-us/dotnet/api/system.datetime?view=netcore-3.1
https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex?view=netcore-3.1
