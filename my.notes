Agile_software_development-------------------------------------------{{{
	Don't say done. It is not a boolean, it has a range. How done do you want it?
	Instead, say deployable. Means, the dev is satisfied with the work and it can be shipped 
	CTO Uncle Bob's expectations:
		We will not ship shit
		We will always be ready: at the end of each sprint, we have deployable (Q&A'd, tested, documented, functional)
		Stable Productivity: you will write code as fast now as in one year, because you won't make a mess and the code will be easy to browse through
		Inexpensive adaptaility: software has to be always soft - easy to change
		Continuous improvement: boyscout rule
		Fearless competence: you see nasty code. You want to clean it. But if you do, you break it. And when you break it, it's yours and you don't want that. Fear means you don't want to clean, and if you don't clean it, it will rot. It will get worse and worse and worse.
		QA will find nothing
		Testing should be vastly automated
----------------------------------------------------}}}
Clean_code-------------------------------------------{{{
	public Output Method(Input input){
		this.DependencyNumberOne.DoSomething(input.AProperty);

		return new Output();
	}
	A method has input, extracts stuff from that input, then passes it to a dependency
	A method can also have an algorithm that is more complex
	Defensive programming is my preference because the error handling is separated from the algorithm
	So, a method has input, extracts stuff from that input in a simple manner (property or lambda please), and passes it no matter which value it is to a dependency. The dependency should then check in guard clause what is valid or not, and throw an exception is the value has no meaning. That being done, there can be a try catch on the calling method.
----------------------------------------------------}}}
Interview_questions -------------------------------------------{{{
	Can you give me three things that the codebase inspires to you?
	What are your thoughts on your position relative to the state of the art?
	What are three things that you can tell me right now to convince me the codebase isn't an absolute mess?
	How often do coworkers gather outside of work and work events?
	What's the distance in number of steps, stairs, doors, stations, airports, spatial stations between a dev and the closest business analyst?
	How often does the customer get to play with a new feature?
	What are three things that the team does to protect itself from technical debt?
	What are three things that the team does to be up to date with modern tooling, practices, language features, and technologies?
	What does it mean for you that "the software works" ?
	What does it mean for you that "the work is done" ?
----------------------------------------------------}}}
Task_workflow-------------------------------------------{{{
	Let's apply DDD!
	A task is `validated` when it has acceptance tests wrapped around a canonical example
	Task{
		Title
		Short Wording
		Additional context or notes
		CanonicalExamples and acceptance tests
		Dev notes
	}
----------------------------------------------------}}}
Unit_tests-------------------------------------------{{{
	As a developer, when all the unit tests pass, I want to have absolute confidence that every _required_ behaviour of the system is validated
----------------------------------------------------}}}
Vim-------------------------------------------{{{
	[SO]What is your most productive shortcut with vim ?-------------------------------------------{{{
	----------------------------------------------------}}}
----------------------------------------------------}}}
-------------------------------------------{{{

